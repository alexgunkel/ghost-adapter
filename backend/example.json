{"posts":[{"id":"643e5b694c8521042abddccb","uuid":"7d156188-6f25-40c6-876e-174dc46d8eb9","title":"CodeCrafters – Fortbildung braucht einen neuen Ansatz","slug":"codecrafters","html":"<p>Wer als Junior-Entwickler:in in die Berufswelt einsteigt, hat in aller Regel bereits fundierte Kenntnisse in mindestens einer Programmiersprache und bereits kleinere Projekte (oft zu Übungszwecken) absolviert. Um gute Senior- oder gar Lead-Developer zu werden, müssen Entwickler:innen nun aber weitere Fähigkeiten erwerben, die oft ganz anders geartet sind, als die ursprünglich erworbenen Programmierkenntnisse. Zunächst kommen Fähigkeiten hinzu, sauberen, wartbaren und aufgeräumten Code zu schreiben, Projekte zu analysieren und Schwachstellen zu verbessern. Von Senior-Entwickler:innen werden Kompetenzen im Bereich der Softwarearchitektur verlangt und Lead-Developer müssen insbesondere über kommunikative und Führungskompetenzen verfügen.</p><p>Die Anforderungen an die verschiedenen Karrierestufen unterscheiden sich teilweise grundlegend. So sollen Seniorentwickler:innen plötzlich über Kompetenzen in der Softwarearchitektur verfügen, ohne dass dies zuvor bereits zu ihren Aufgaben gehörte. Es ist ein Irrglaube, diese Fähigkeiten entwickelten sich einfach als Ergebnis mehrjähriger Erfahrung. Sie müssen vielmehr explizit erworben werden. In manchen Unternehmen gibt es spezielle Mentoringprogramme für junge Softwareentwickler:innen. Aber nicht jedes Unternehmen kann entsprechende Ressourcen aufbringen. Außerdem verfügt nicht jeder Senior-Kollege und Mentor über entsprechende didaktische Erfahrung und Freude an der Weitergabe seines Wissens.</p><p>Viele Kompetenzen, die den Unterschied markieren zwischen Einsteiger:innen in die professionelle Softwareentwicklung und gestandenen Seniorentwickler:innen, beziehen sich nicht auf eine konkrete Technik oder bestimmte Programmiersprache, sondern auf Fragen des Softwaredesigns, der Architektur und des methodischen Vorgehens. Domain Driven Design, Test-Driven Development und Modularisierung lassen sich in ganz verschiedenen Sprachen erreichen (und eben auch verfehlen). Gerade diese Kompetenzen kommen in der Weiterbildung leider oft zu kurz – zumindest insofern sich Entwickler:innen nicht selbst in Meet-Ups und Selbststudium damit beschäftigen oder durch Glück an einen versierten Mentor oder eine versierte Mentorin geraten.</p><p>Gerade mittelständische Unternehmen haben im Wettbewerb um qualifizierte Softwareentwickler oft das Nachsehen gegenüber den großen Unternehmen wie Amazon, Google oder Otto, die nicht nur mit hoher Bezahlung, sondern auch mit einem hochprofessionellen Umfeld und begeisternden Aufgaben punkten können. Die Herausforderung an das Recruiting ist nicht nur, Softwareentwickler:innen zu finden, sondern gerade auch, solche Entwickler:innen zu finden, die entsprechende Kompetenzen und Erfahrungen mitbringen, um Projekte erfolgreich zu meistern. Gerade in Sprachen wie PHP oder JavaScript (und generell in der Web-Entwicklung) verfügen viele Softwareentwickler:innen nicht über die Fähigkeiten und Erfahrungen, um komplexe Herausforderungen zu meistern.</p><p>Heutzutage sind viele Entwickler:innen keine ausgebildeten Informatiker, sondern kommen aus verschiedenen anderen Fachrichtungen und Berufen. Diese Menschen haben sich das Coden selbst beigebracht oder entsprechende Fortbildungen und Workshops (<em>Boot-Camps</em>) besucht, die ihnen die Grundlagen ihrer Tätigkeit beibrachten. Data Scientists und Business Analysts haben oft einen akademischen Hintergrund in Mathematik oder Wirtschaftswissenschaften und gießen ihre Fachexpertise in Software, ohne zuvor im eigentlichen Sinne Softwareentwicklung gelernt zu haben. Quereinsteiger bringen eigene Perspektiven und Fähigkeiten ein und bereichern Unternehmen damit um etwas, was mit homogeneren Teams nicht zu erreichen wäre. Mehr als andere sind sie dafür auf ein <em>Training on the Job</em> angewiesen. Während ihre Kollegen mit Informatikausbildung bereits von <em>Design Patterns</em> und hexagonaler Architektur gehört haben, müssen sie auch diese Konzepte nachträglich erlernen, um zu seniorigen Entwicklerinnen und Entwicklern zu werden.</p><h1 id=\"was-es-braucht\">Was es braucht</h1><p>Was meines Erachtens benötigt wird, ist eine systematische Fortbildung von Entwickler:innen in den allgemeinen Kompetenzen der Softwareentwicklung. Und genau daran mangelt es noch immer: Es fehlt eine Fortbildungskultur in der deutschen IT-Landschaft, wie kürzlich Rainer Grimm nochmal völlig zurecht beklagte (<a href=\"https://www.heise.de/meinung/Mangel-an-Fortbildung-Warum-die-Kulturlosen-keine-Chance-haben-8191399.html\">Mangel an Fortbildung: Warum die Kulturlosen keine Chance haben</a>). Es reicht nicht, mal ein einzelnes Seminar zum Clean-Code zu besuchen. Stattdessen müssen wir die Fortbildung verstetigen, indem wir Junior-Entwickler mit Software-Craftsmanship vertraut machen und Intermediate- und Senior-Entwickler systematisch in Softwarearchitektur schulen.</p><p>Es genügt auch nicht, sich mit Videos und Tutorials auf Plattformen wie Udemy zu versorgen. Softwareentwicklung ist wie Handwerk ein ganz praktisches Können, das zur Ausbildung der Übung bedarf. Viele ambitionierte Software-Engineers setzen daher auf sogenannte Katas, die sie immer wieder üben, um ihre Fähigkeiten zu perfektionieren. Katas (der Begriff bezeichnet ursprünglich eine Übungsform in Kampfkünsten) sind kleine, in sich geschlossene Aufgaben, die darauf abzielen, bestimmte Aspekte der Software-Entwicklung zu verbessern, wie beispielsweise Design, Code-Qualität oder Testbarkeit. Katas können auch verwendet werden, um neue Programmiersprachen oder Frameworks zu erlernen und zu üben. In der Regel werden sie allein oder in kleinen Gruppen durchgeführt und können dazu beitragen, ein regelmäßiges Übungsprogramm zu etablieren, das die Fähigkeiten und Kenntnisse der Software-Entwickler verbessert.</p><p>Meine Vision ist ein Fortbildungsangebot für Entwickler:innen, das sie von Beginn an begleitet:</p><ul><li>Junior-Devs werden in Software-Craftsmanship geschult, der Basis für jeden weiteren Erfolg.</li><li>Intermediate- und Senior-Devs erhalten einen Einblick in die Softwarearchitektur.</li><li>Alle Einheiten sind kompetenzorientiert und enthalten Übungen, die auf die täglichen Aufgaben als Entwicker vorbereiten und wirklich benötigte Kompetenzen fördern.</li></ul><h1 id=\"meine-expertise\">Meine Expertise</h1><p>Ich kenne den Weg als Quereinsteiger in die Softwareentwicklung aus eigener Erfahrung. 2015 beschloss ich, die universitäre Laufbahn nach der Promotion zu verlassen und eine ganz andere Richtung zu versuchen. Ohne viele Kenntnisse im Bereich Software und IT entschied ich mich, Programmieren und Web-Entwicklung zu lernen, und heuerte in einer Agentur in Leipzig an. Zwei Jahre später wurde ich Senior-Entwickler bei einem großen deutschen Vergleichsportal.</p><p>Auf dem Weg dorthin hatte ich bereits viel gelernt: PHP, JavaScript, HTML, CSS, SASS und MySQL, Git und Continuous Integration, aber vor allem auch, was es heißt, Clean Code zu schreiben, testgetrieben zu entwickeln, Design Patterns zu verstehen, zu entwerfen und zu diskutieren, und warum es oft besser ist, alles in Form von Code zu verwalten statt in Wikis und Word-Dokumenten. Ich hatte mitgeholfen, Docker im Unternehmen einzuführen, und hatte ein erstes Projekt in einer damals noch wenig verbreiteten Sprache initiiert: Golang (freilich zu 80% in meiner Freizeit). Daneben schob ich einen wöchentlichen Workshop innerhalb des Unternehmens an: Unter dem Titel DevSamurai wurden wöchentlich neue Technologien vorgestellt sowie SOLID-Prinzipien und Fragen der Softwarearchitektur diskutiert.</p><p>Sicherlich half mir, dass ich während meines Studiums und als wissenschaftlicher Mitarbeiter an der Universität darauf getrimmt wurde, mir Wissen und Fertigkeiten selbst anzueignen. Ich weiß, wie ich an Informationen komme und was ich tun muss, um mir eine Fertigkeit selbst beizubringen. Ebenso weiß ich, wie ich das Wissen an andere Menschen weitergebe: Schon im Studium verdiente ich einen Teil meines Lebensunterhalts als Nachhilfelehrer und Tutor. Als wissenschaftlicher Mitarbeiter und Lehrbeauftragter konzipierte und leitete ich eine Vielzahl eigener Lehrveranstaltungen und begeisterte mich für kompetenzorientierte und methodisch versierte Unterrichtsformenin. Genau das mache ich nun auch im Bereich der Softwareentwicklung – und helfe so Neueinsteigern auf ihrem Weg zum professionellen Senior-Softwareentwickler.</p><h1 id=\"inhalt\">Inhalt</h1><p>Die technologieübergreifenden Kompetenzen, die wir auf dem Weg von Programmieranfänger:innen zu Senior-Entwickler:innen erwerben müssen, lassen sich grob in zwei aufeinander aufbauende Bereiche einteilen: Am Anfang stehen Fähigkeiten und Gewohnheiten, die ich unter dem Titel <strong>Software-Craftsmanship</strong> zusammenfasse, und die von Clean Code über Unit-Testing bis hin zum versierten und verantwortungsvollen Umgang mit Design Patterns reichen. Darauf aufbauend geht es um die verschiedenen Themen der <strong>Software-Architektur</strong>, die sich mit den ganzen Softwaresystemen befasst und die Zielsetzungen das Software-Craftsmanship auf einer abstrakteren Ebene verfolgt.</p><h2 id=\"software-craftsmanship\">Software-Craftsmanship</h2><p>Die Entwicklung von Software ist ein Handwerk – nicht im rechtlichen Sinne (der Handwerkskammer müssen wir als Softwareentwickler:innen nicht beitreten), aber doch in der Art der Tätigkeit. Dieser Einsicht folgend sprechen engagierte Softwareentwickler:innen auch von Softwareentwicklung als einer Handwerkskunst (<em>Craftsmanship</em>). Software Craftsmanship ist ein Ansatz zur Softwareentwicklung, der sich auf die Qualität der erstellten Software und auf die kontinuierliche Verbesserung der Fähigkeiten der Entwickler konzentriert. Es geht um die Schaffung von Code, der nicht nur funktioniert, sondern auch sauber, lesbar, wartbar und erweiterbar ist. Dies beinhaltet zum Beispiel:</p><ul><li><strong>Kontinuierliche Verbesserung</strong>: Software-Craftsmanship fördert die kontinuierliche Verbesserung der Fähigkeiten eines Entwicklers sowie der Qualität des Produkts.</li><li><strong>Clean Code</strong>: Software-Craftsmanship legt großen Wert auf sauberen Code, der leicht zu lesen und zu verstehen ist. Dies ermöglicht es anderen Entwicklern, den Code leichter zu warten und zu erweitern.</li><li><strong>Best Practices</strong>: Dies umfasst unter anderem die Verwendung von Versionierungstools, Test-Driven Development (TDD), Continuous Integration (CI) und Continuous Deployment (CD).</li><li><strong>Teamarbeit</strong>: Software-Craftsmanship verbessert die Zusammenarbeit zwischen Entwicklern. Durch die Zusammenarbeit und Kommunikation können Entwickler ihr projektspezifisches Wissen erweitern und bessere Software entwickeln.</li></ul><h2 id=\"software-architektur\">Software-Architektur</h2><p>Softwarearchitektur befasst sich mit der Planung und dem Entwurf der Struktur und Organisation von Software-Systemen und zielt darauf ab, die funktionalen und nicht-funktionalen Anforderungen an eine Software vor dem Hintergrund realistisch eingeschätzter Rahmenbedingungen zu erreichen. Sie hat damit das Ganze eines Softwaresystems vor Augen und nimmt eine leitende Funktion innerhalb des Gesamtprozesses ein. Damit ist Softwarearchitektur eine entscheidende Kompetenz guter Senior- und Lead-Developer und nach dem Software-Craftsmanship der nächste Schritt in der Entwicklung übergreifender Kompetenzen.</p><p>Eine gute Softwarearchitektur ermöglicht es, komplexe Systeme in klar definierte Teile zu zerlegen, die unabhängig voneinander entwickelt, getestet und gewartet werden können. Die Aufgaben der Softwarearchitektur sind vielfältig und umfassen unter anderem:</p><ul><li><strong>Anforderungsanalyse</strong>: Die Softwarearchitektur muss die Anforderungen der Benutzer verstehen und diese in eine Architektur übersetzen, die diese Anforderungen erfüllt.</li><li><strong>Design</strong>: Die Softwarearchitektur muss eine Struktur für die Software entwerfen, die es ermöglicht, dass die verschiedenen Komponenten effektiv zusammenarbeiten, um die Anforderungen der Benutzer zu erfüllen.</li><li><strong>Auswahl von Technologien</strong>: Die Softwarearchitektur muss die richtigen Technologien auswählen, die am besten geeignet sind, um die Anforderungen der Benutzer zu erfüllen und die Ziele der Software zu erreichen.</li><li><strong>Implementierung</strong>: Die Softwarearchitektur muss sicherstellen, dass die Implementierung der Software den Entwurf der Architektur und die ausgewählten Technologien korrekt umsetzt.</li><li><strong>Integration</strong>: Die Softwarearchitektur muss sicherstellen, dass die verschiedenen Komponenten der Software effektiv integriert werden, um sicherzustellen, dass die Software wie geplant funktioniert.</li><li><strong>Bewertung und Überprüfung</strong>: Die Softwarearchitektur muss die Architektur der Software regelmäßig bewerten und überprüfen, um sicherzustellen, dass sie den Anforderungen der Benutzer entspricht und effektiv und effizient funktioniert.</li><li><strong>Dokumentation</strong>: Die Softwarearchitektur muss die Architektur der Software dokumentieren, um sicherzustellen, dass andere Entwickler die Architektur verstehen und effektiv damit arbeiten können.</li></ul><p>Die Bedeutung der Softwarearchitektur wird in IT-Projekten oft unterschätzt: Wenn Projekte in's Stocken geraten, die Komplexität langsam unbeherrschbar wird und neue Features schwer zu implementieren sind, dann liegt das nicht zuletzt an einer schlechten Architektur. Wir merken dass, wenn die Liste der Bugtickets immer länger wird und wir uns im Planning Poker immer öfter verschätzen.</p><h1 id=\"vorteile-f%C3%BCr-unternehmen\">Vorteile für Unternehmen</h1><p>Eine systematische Schulung der Entwickler:innen bringt dem Unternehmen dadurch eine ganze Reihe von Vorteilen:</p><ul><li><strong>Verbesserte Produktqualität</strong>: Software-Entwickler, die ihre Fähigkeiten und Kenntnisse in diesen Bereichen verbessern, können dazu beitragen, eine höhere Qualität der entwickelten Software-Produkte zu gewährleisten. Dadurch können die Produkte besser den Anforderungen der Kunden entsprechen und eine höhere Kundenzufriedenheit erreichen.</li><li><strong>Reduktion von Projektrisiken</strong>: Gerade bei komplexer werdenden Projekten steigen mit der Zeit die Projektrisiken, die aus mangelnden handwerklichen und architektonischen Fähigkeiten erwachsen. Im schlimmsten Fall droht ein Projekt wegen falscher Technologieauswahl, mangelnder Qualitätskontrolle oder unrealistischen bzw unklaren Anforderungen vollständig zu scheitern. Oft erlebe ich auch, dass Projekte von dem dienstältesten Entwickler am Standort abhängen und gerade anspruchsvollere Aufgaben nur von dieser einen Person erledigt werden können. Was aber geschieht, wenn diese einzelne Person krank wird oder aus dem Unternehmen ausscheidet? Besser ist es, solche Entwicklungen von vornherein zu vermeiden, Kompetenzen breiter zu verteilen und bestehende Projekte zukunftssicher aufzustellen. Durch eine systematische Investition in die Kernkompetenzen der Entwicklerinnen und Entwickler entstehen so <strong>zukunftssichere Projekte</strong>.</li><li><strong>Erhöhte Effizienz</strong>: Laut einer <a href=\"https://www.it-cisq.org/the-cost-of-poor-quality-software-in-the-us-a-2022-report/\">Studie des CISQ</a> (<em>Consortium for Information &amp; Software Quality</em>) aus dem Jahr 2022 büßen Entwickler:innen etwa ein Drittel ihrer Produktivität durch schlechten Code ein. Erfahrene Entwickler:innen wissen: Je komplexer ein Projekt ist, desto gravierender werden die Auswirkungen technischer Schulden, wenn es um die Implementierung neuer Features geht. Waren neue Features zu Beginn des Projekts noch schnell implementiert und ausgerollt, wird der Prozess mit der Zeit quälend langsam und fehleranfällig. Da mehren sich die Bug-Tickets im Backlog und Entwickler:innen benötigen ein Vielfaches der geschätzten Zeit für die Umsetzung ihrer Tickets. Durch das Beherrschen von Software-Craftsmanship und bessere architektonische Entscheidungen können Projekte auch langfristig schneller abgeschlossen werden und das Unternehmen kann schneller auf Marktveränderungen reagieren.</li><li><strong>Höhere Mitarbeitermotivation</strong>: Fortbildungsmöglichkeiten können dazu beitragen, dass Mitarbeiter sich wertgeschätzt und unterstützt fühlen. Dadurch kann die Mitarbeitermotivation gesteigert werden, was zu einer höheren Arbeitsqualität und Produktivität führt sowie zu <strong>geringerer Personalfluktuation</strong>. Zugleich erwirbt sich das Unternehmen dadurch einen Vorteil im <strong>Recruiting</strong>: Perspektiven für die berufliche Entwicklung aufzuzeigen kann der entscheidende Faktor in der Anwerbung neuer Talente sein. Damit sprechen Sie genau diejenigen an, die motiviert in ihren Beruf starten.</li></ul><h1 id=\"vorteile-f%C3%BCr-entwicklerinnen\">Vorteile für Entwickler:innen</h1><p>Für Entwickler:innen, die sich weiterentwickeln möchten, ist es interessant, weil sie dadurch bessere Entwicklungsmöglichkeiten haben und ihr Potential besser entfalten können.</p><ul><li>Ihnen stehen bessere <strong>Karrieremöglichkeiten</strong> offen, da sie sich früher für Positionen als Senior oder Lead-Developer qualifizieren. Damit einher gehen <strong>anspruchsvollere Aufgaben</strong> und <strong>interessantere Projekte</strong>. Nicht zuetzt geht damit die Aussicht auf ein <strong>höheres Gehalt</strong> einher. Schließlich werden bessere Entwickler:innen auch für ihre Arbeitgeber interessanter und steigern so ihren eigenen Marktwert.</li><li>Nur wer sich weiterentwickelt, wird zukünftig weiter lukrative Betätigungsfelder vorfinden. Einfache Programmieraufgaben werden zunehmend obsolet und durch smarte Technologien ausgeführt. <strong>Low Code und KI sind aktuelle Trends, die die Existenzgrundlage des Code Monkeys akut gefährden.</strong> Nur wer sich weiterentwickelt und für anspruchsvollere Aufgaben qualifiziert, wird eine Zukunft in der Softwareentwicklung haben. Das bloße Ausführen vorgegebener Programmieraufgaben können uns heute schon Maschinen abnehmen.</li><li>Schlussendlich geht es uns immer auch darum, <strong>Freude an der Tätigkeit</strong> der Softwareentwicklung zu haben. Linux Torvalds sagte einmal, die besten Entwickler arbeiteten nicht des Geldes wegen, sondern weil es ihnen einfach Spaß macht. Spaß macht Softwareentwicklung aber nur, wenn das Ergebnis qualitativ gut ist und wir den steigenden Herausforderungen gewachsen sind.</li></ul><h1 id=\"fazit\">Fazit</h1><p>Die Ausbildung technologieübergreifender Kompetenzen von Softwareentwicklern wird in vielen Unternehmen sträflich vernachlässigt. Software-Craftsmanship und Softwarearchitektur sind integrale Bestandteile agiler Softwareentwicklung, werden aber nicht immer als solche erkannt. Das begrenzt nicht nur das Entwicklungspotential von Entwickler:innen und die Qualität der Resultate, es führt zu Mehrkosten und unüberschaubaren Projektrisiken. Denn miese Softwarequalität ist teuer und riskant. Wer sich weiterentwickeln möchte – ob als Entwickler:in oder als Unternehmen – muss hier umdenken und den fortgeschrittenen Kompetenzen mehr Raum geben.</p>","comment_id":"643e5b694c8521042abddccb","feature_image":"https://blog.alexandergunkel.eu/content/images/2023/04/Penguins_in_classroom.png","featured":false,"visibility":"public","created_at":"2023-04-18T10:57:13.000+02:00","updated_at":"2023-07-13T15:39:23.000+02:00","published_at":"2023-04-18T12:02:22.000+02:00","custom_excerpt":"Der Softwareentwicklung mangelt es an einer adäquaten Fortbildungskultur. Oft wird nur die Fortbildung in einzelnen Technologien unterstützt, aber keine systematische Entwicklung in Bereichen wie Softwarearchitektur. Besonders wichtig wäre dies für Quereinsteiger, die sich weiterentwickeln möchten.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"url":"https://blog.alexandergunkel.eu/codecrafters/","excerpt":"Der Softwareentwicklung mangelt es an einer adäquaten Fortbildungskultur. Oft wird nur die Fortbildung in einzelnen Technologien unterstützt, aber keine systematische Entwicklung in Bereichen wie Softwarearchitektur. Besonders wichtig wäre dies für Quereinsteiger, die sich weiterentwickeln möchten.","reading_time":9,"access":true,"comments":false,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":"CodeCrafters – Fortbildung braucht einen neuen Ansatz","meta_description":"Uns fehlt eine Fortbildungskultur. Statt vereinzelter Udemy-Kurse braucht es regelmäßige Übung in den Grundfertigkeit des Software-Engineerings.","email_subject":null,"frontmatter":null,"feature_image_alt":"Pinguine während der Fortbildung","feature_image_caption":null},{"id":"6417553f4c8521042abddc4f","uuid":"be344240-4aa1-4540-b00e-ef740db896cf","title":"\"Ich schreib da mal ein Ticket\"","slug":"ich-schreib-da-mal-ein-ticket","html":"<p>Zu den Sätzen, die vermutlich alle Entwicklerinnen und Entwickler, die in einem agilen Umfeld arbeiten, schon oft gehört (oder auch selbst gesprochen) haben, gehört: \"Ich schreib da mal ein Ticket.\" Dieser Satz wird verwendet, sobald irgendein Bug auffällt, eine Unsauberkeit im Code, ein Problem in der Infrastruktur oder eine unzureichende Testabdeckung im aktuellen Feature. Statt den Fehler zu beheben oder den Code aufzuräumen, wird die Arbeit vertagt, sprich: \"in's Backlog verschoben\". Das wirkt agil, schließlich gibt die Vertagung zeitliche Ressourcen frei, um sich anderen Feature-Wünschen zu widmen und die Velocity zu erhöhen.</p><p>Ich kenne keine genauen Statistiken dazu, wie oft einmal geschriebener Code von anderen Entwicklern im Schnitt gelesen und verstanden werden muss. Die eigene Erfahrung sagt aber, dass wir viel mehr Code lesen als schreiben und auch mehr Zeit damit verbringen, vorhandene Software zu verstehen als neue Features zu implementieren. Es lohnt sich daher, den Code so verständlich wie möglich zu machen, denn beim Verstehen sind die größten zeitlichen Einsparungen möglich. Umso verwunderlicher ist die Haltung, das Aufräumen (Refactoring, Testen etc.) nicht sofort zu machen, sondern in die Zukunft zu verschieben. Bis es wirklich dazu kommt, dass das Aufräum-Ticket aus dem Backlog in den aktuellen Sprint gezogen wird, haben sich mitunter schon mehrere Entwickler um ein Verständnis des halbfertigen Ergebnisses bemühen müssen.</p><p>Jede kurzfristig gesparte Minute kann sich rächen, insbesondere durch den Verlust von Flexibilität. Wer auf neue Feature-Wünsche reagieren und die Velocity dauerhaft hochhalten möchte, braucht nichts mehr als sauberen, aufgeräumten und getesteten Code und eine stringente Architektur. Das geht aber nur, wenn Clean Code und Refactoring zum Abschluss eines Features selbstverständlich dazugehören.</p><p>Plausibel wirkt das beschrieben Vorgehen vielleicht auch nur auf diejenigen, die selbst keinen Code schreiben, also auf Produktmanager, Product Owner, Scrum Master etc. Sie sehen in diesem Fall nur die streng funktionalen Anforderungen und verlieren nicht-funktionale Qualitätsmerkmale wie Wartbarkeit, Robustheit, Verständlichkeit und Analysierbarkeit aus den Augen.</p><p>Für viele Entwickler ist aus den genannten Gründen klar, dass immer <strong>jetzt</strong> der beste Zeitpunkt zum Aufräumen ist. Für alle anderen möchte ich einen Vergleich anbieten: Man stelle sich vor, ein Handwerker verzichte nach getaner Arbeit darauf, seine Werkzeuge und die Werkstatt aufzuräumen, und schriebe stattdessen ein Ticket, um das Aufräumen bei Gelegenheit nachzuholen; oder in der Buchhaltung würden die Belege nicht zeitnah in entsprechende Ordner einsortiert, sondern erstmal auf anwachsenden Stapeln gelagert, bis im nächsten Frühjahr wirklich die Unterlagen für die Steuer fertig gemacht werden. Das mag mancher privat so machen, in einem professionellen Umfeld ist das aber undenkbar. Und genauso verhält es sich mit der Entwicklung von Software: Ein privates Hobbyprojekt mag unaufgeräumt bleiben (was ich dennoch nicht emfehle, ebensowenig wie der ungeordnete Stapel für die Steuerunterlagen). Soll Software professionell entwickelt werden, verbietet sich das.</p>","comment_id":"6417553f4c8521042abddc4f","feature_image":"https://blog.alexandergunkel.eu/content/images/2023/03/PXL_20230319_183726693.jpg","featured":false,"visibility":"public","created_at":"2023-03-19T19:32:31.000+01:00","updated_at":"2023-03-19T19:45:52.000+01:00","published_at":"2023-03-19T19:45:52.000+01:00","custom_excerpt":"Die Haltung, das Aufräumen des Codes (Refactoring, Testen etc.) in die Zukunft zu verschieben, um Zeit für neue Features zu gewinnen, kann zu Verlust von Flexibilität und Wartbarkeit führen und Clean Code sowie Refactoring sollten daher zum Abschluss jedes Features selbstverständlich dazugehören.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"url":"https://blog.alexandergunkel.eu/ich-schreib-da-mal-ein-ticket/","excerpt":"Die Haltung, das Aufräumen des Codes (Refactoring, Testen etc.) in die Zukunft zu verschieben, um Zeit für neue Features zu gewinnen, kann zu Verlust von Flexibilität und Wartbarkeit führen und Clean Code sowie Refactoring sollten daher zum Abschluss jedes Features selbstverständlich dazugehören.","reading_time":2,"access":true,"comments":false,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"email_subject":null,"frontmatter":null,"feature_image_alt":"Ein Stapel mit Unterlagen","feature_image_caption":"Ein Stapel mit Unterlagen, die vielleicht irgendwann mal wieder gebraucht werden."},{"id":"640b415973c6dcb1f2fbd1dd","uuid":"b5e5c025-44b4-465d-8b48-c506a3b7ace3","title":"Error Handling in Golang","slug":"error-handling-in-golang","html":"<p>Go geht an einigen Stellen recht eigene Wege und dies gilt insbesondere auch für den Umgang mit Fehlern, in dem sich Go sowohl von dem Konzept der Exceptions wie in Java, <a href=\"https://en.cppreference.com/w/cpp/language/throw\">C++</a> oder PHP distanziert, als auch einen anderen Weg als C mit seinen Error-Codes, <a href=\"https://en.cppreference.com/w/cpp/error/error_code\">wie sie auch in C++ noch verwendet werden</a>. Dabei scheint mir der Umgang mit Fehlern in Go durch drei Prinzipien geprägt zu sein:</p><ol><li><strong>Fehler sind</strong> keine außergewöhnlichen Geschehnisse, sondern <strong>ein ganz normaler Vorgang</strong> in Softwareprogrammen, also eher die Regel als eine Ausnahme.</li><li>Fehler sollten immer <strong>explizit</strong> behandelt werden. Ein implizites Durchreichen wie bei Exceptions gilt es zu vermeiden.</li><li>Der Umgang mit Fehlern soll <strong>einfach</strong> sein und die sprachlichen Mittel nicht unnötig aufblähen.</li></ol><p>Die beiden letzten Punkte sind sicherlich allgemeine Grundsätze, die das Design der Sprache Go prägen, und keine spezifischen Besonderheiten in Bezug auf Fehler.</p><p>Ich möchte hier ein paar Grundsätze für das Go-typische Error-Handling vorstellen und begründen, warum ich in vielen Punkten an Konzepten und Regeln festhalte, die uns aus der Verwendung von Exceptions bekannt sind. Meines Erachtens unterscheiden sich die Prinzipien eines effektiven Error-Handlings nicht grundlegend zwischen Go und Sprachen mit Exceptions.</p><h2 id=\"das-interface\">Das Interface</h2><p>Dem Grundkonzept nach braucht es für die Fehlerbehandlung in Go gar keine besonderen Sprachmittel. So lautet das native Interface:</p><pre><code>type error interface {\n\tError() string\n}\n</code></pre><p>Die Standardimplementierung braucht dann auch nichts weiter als eine <code>struct</code>, die dieses Interface implementiert. Alles, was dies zu einer nativen Implementierung macht, ist die Tatsache, dass das error-Interface ohne Import eines Packages zur Verfügung steht und in allen Packages verwendet werden kann, obwohl sie nicht explizit exportiert wurde. Die Funktionaltät könnten wir auch ohne dieses Built-In-Interface durch ein eigenes Interface erwerben.</p><h2 id=\"multiple-r%C3%BCckgabewerte\">Multiple Rückgabewerte</h2><p>Mächtig wird das Konstrukt durch eine andere Eigentümlichkeit der Sprache: Multiple Rückgabewerte. So kann eine Funktion neben ihrem 'eigentlichen' Ergebnis noch ein zweites (oder mehr) weitere Ergebnisse haben und beispielsweise einen Fehler zurückgeben:</p><pre><code>func (app *App) readConfig() (string, error) {\n\tdata, err := os.ReadFile(app.configFile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t...\n}\n</code></pre><p>Die Funktion <code>ReadFile</code> aus dem Package <code>os</code> gibt neben den gelesenen Daten einen <code>error</code> zurück. Dieser ist <code>nil</code>, wenn die Funktion fehlerfrei ausgeführt werden konnte, enthält aber einen entsprechenden Fehler, wenn etwa die Datei nicht existiert. Falls ein möglicherweise auftretender Fehler ignoriert werden soll, kann dies durch das Built-In <code>_</code> erreicht werden:</p><pre><code>func (app *App) readConfig() string {\n\tdata, _ := os.ReadFile(app.configFile)\n\t...\n}\n</code></pre><p>Allerdings gilt es hier zu beachten, dass auftretende Fehler nicht bemerkt werden und entsprechend nicht behandelt werden können.</p><h2 id=\"bubbling\">Bubbling</h2><p>Ein oft beobachtbares Vorgehen ist das sogenannte <strong>Bubbling</strong>. Dabei werden Fehler aus einer aufgerufenen Funktion direkt in die nächsthöhere Funktion weitergereicht:</p><pre><code>func doStuff() {\n err := fnt()\n if err != nil {\n   return err\n }\n}\n</code></pre><p>Das kann über viele Stationen geschehen und macht explizit, was Exceptions in anderen Sprachen implizit machen: Es verlagert den Programmablauf aus einer tiefen Stelle im Programm an eine höhere Stelle, wo sinnvoll auf eine bestimmte Situation reagiert werden kann. Im Falle von Exceptions geschieht der Spring automatisch von dem <code>throw</code>-Aufruf zum korrespondierenden <code>catch</code>-Block.</p><h2 id=\"panic-und-recover\">panic() und recover()</h2><p>Gänzlich unterschieden von <code>error</code> ist das Konzept von <code>panic(str string)</code> und <code>recover()</code>, die eine völlig andere Art der Fehlerbehandlung einführen. Ein Aufruf von <code>panic</code> führt zunächst zum sofortigen Absturz des Programms, insofern er nicht durch ein <code>recover()</code> abgefangen wird. Dadurch sind Sprünge von einer Stelle des Programms zu einer ganz anderen Stelle ähnlich wie bei Exceptions möglich. Mein Eindruck ist, dass die korrekte Verwendung von <code>panic</code> am ehesten der von Logic-Exceptions in Sprachen mit Exceptions ähnelt, die Nutzung von <code>error</code> sich hingegen in vielen Dingen an dem Umgang mit Runtime-Exceptions orientieren sollte. Ein <code>error</code> ist oft die sinnvollste Reaktion auf ungünstige Rahmenbedingungen, während <code>panic</code> dort sinnvoll ist, wo eine Situation auf einen schwerwiegenden Programmierfehler hindeutet. Entsprechend sollte <code>panic</code> nicht verwendet werden, um reparable Fehler zur Laufzeit zu behandeln. Man sieht immer wieder Versuche, ein 'eleganteres' Error-Handlung durch <code>panic</code>-<code>recover</code>-Kombinationen zu implementieren und teils auch Exceptions nachzuahmen. Hier gilt der Grundsatz: Don't be clever! Die Sprache Go nutzt dafür <code>error</code>, nicht <code>panic</code>!</p><h1 id=\"best-practices\">Best Practices</h1><p>Go ist so konzipiert, dass es Teams mit unterschiedlichem Erfahrungsstand helfen soll, gemeinsam gute, robuste Software mit hoher Qualität zu entwickeln. Etwas despektierlicher ließe sich auch sagen: Ein schlechter Entwickler soll in der Sprache möglichst wenig Schaden anrichten können. Dennoch verlangt Go von den Entwicklerinnen und Entwicklern, sich auf die Sprache einzustellen und idiomatische Programmierstile zu entwickeln (ich habe darauf bereits <a href=\"https://blog.alexandergunkel.eu/was-ist-go-und-warum-ist-es-einer-meiner-backend-favoriten/\">hier</a> verwiesen). Es lassen sich eben doch suboptimale Ergebnisse erzielen, wenn die Eigentümlichkeiten der Sprache nicht hinreichend reflektiert werden.</p><p>Im Bereich des Umgangs mit Fehlern gibt es eine ganze Reihe von Caveats, die spätestens dann relevant werden, wenn das Projekt komplexer wird, im Produktivbetrieb Bugs auftreten oder neue Anforderungen eine Revision erfordern. Ein häufiges Problem in Go ist das Auftreten vieler, teils redundanter Logmeldungen mit geringem Informationsgehalt und ohne wirklichen Mehrwert:</p><pre><code>2023-01-15 11:02:13.1261 timeout\n2023-01-15 11:02:13.1265 sending failed\n2023-01-15 11:02:14.2514 could not store data\n</code></pre><p>Hier weiß niemand, in welchem Kontext das Timeout auftrat, ob es in einem Zusammenhang zu der Meldung \"sending failed\" steht und ob es vielleicht auch das \"could not store data\" verursacht hat. Um solche Situationen zu vermeiden, sollten wir einige Regeln beachten.</p><p>Ich halte die folgenden Grundsätze für entscheidend:</p><ol><li>Jeder Fehler wird an genau einem Ort behandelt. Vermeide partielle Fehlerbehandlungen.</li><li>Vermeide missbräuchliche Verwendungen von <code>error</code> und beschränke die Verwendung auf Situationen, in denen eine Funktion ihre Aufgabe aufgrund ungünstiger Rahmenbedingungen nicht ausführen konnte.</li><li>Ignoriere (fast) keine Fehler, sonder behandle (fast) jeden Fehler explizit. Ausnahmen hierzu deuten auf ein schlechtes Design der Funktionen und Methoden hin.</li><li>Wird ein Fehler aus einer untergeordneten Funktion an eine übergeordnete Funktion durchgereicht, sollen genau diejenigen relevanten Kontextinformationen hinzugefügt werden, über die die aufrufende Funktion nicht verfügt. Niemals sollten Informationen über Art und Inhalt eines Fehlers verloren gehen.</li></ol><h2 id=\"jeder-fehler-wird-an-genau-einem-ort-behandelt\">Jeder Fehler wird an genau einem Ort behandelt</h2><p>Es gibt viele Situationen, in denen es nahe liegt, Fehler stückweise zu behandeln. Da wird dann erstmal eine Logmeldung erstellt und später wird entschieden, dass eine Operation wiederholt, ein Vorgang abgebrochen oder einfach weitergemacht wird. Ja, auch Logging oder die Entscheidung, einen Fehler zu ignorieren und den Vorgang dennoch fortzusetzen, sind Arten der Fehler<strong>behandlung</strong>, ebenso wie das Beenden des Programms, wenn ein konsistenter Zustand nicht mehr erreicht werden kann.</p><pre><code>  ...\n  if err := fnt(param); err != nil {\n    log.Error(err.Error())\n\t  return err\n  }\n  ...\n</code></pre><p>Ein solches Vorgehen ist oft einfach umzusetzen und stellt keine Anforderungen an die Architektur der Anwendung, hat aber den Nachteil größerer Unübersichtlichkeit, aus der dann oft folgt, dass Fehlerbehandlung doppelt ausgeführt wird oder unabsichtlich unterbleibt. An dieser Stelle ist zu befürchten, dass an übergeordneter Stelle wiederum eine Log-Meldung verfasst wird, was zu Redundanzen und Log-Spam führt. Es ist daher besser, eine einzelne Stelle zu finden, an der auf den Fehler eingegangen wird, und den Fehler dann auch nicht weiterzureichen. Besser wäre es, den Fehler an die aufrufende Funktion weiterzureichen:</p><pre><code>  ...\n  if err := fnt(param); err != nil {\n\t  return fmt.Errorf(\"failed doing XYZ with param %s: %w\", param, err)\n  }\n  ...\n</code></pre><p>Anzumerken bleibt, dass die Anreicherung des Fehlers mit Informationen natürlich nicht als Fehlerbehandlung zählt, ebensowenig wie die Freigabe von Resourcen, die innerhalb der Funktion allokiert wurden – wozu aber besser auf ein <code>defer</code> zurückgegriffen werden sollte.</p><h2 id=\"vermeide-missbr%C3%A4uchliche-verwendungen-von-error\">Vermeide missbräuchliche Verwendungen von <code>error</code></h2><p>Wie oben beschriebenen baut Go auf der Prämisse auf, dass Fehler nichts außergewöhnliches sind, sondern im Ablauf eines Programms regelmäßg vorkommen. Deshalb gilt es auch als Anforderung, dass die Erstellung eines <code>error</code>-Objekts mit geringen und feststehenden Kosten verbunden ist (siehe etwa <a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-error-values-overview.md\">hier</a>; das unterscheidet <code>error</code> in Go bspw. von Exceptions in C++, wo es keine Laufzeitgarantien zur Performance gibt). Auch wenn dies vermuten lässt, dass mit Fehlern in Go sehr freizügig umgegangen werden kann, möchte ich doch an einer klassischen Sichtweise festhalten: Ein Fehler ist etwas, was eine Ausnahme darstellen sollte. Er sagt: Ups, das hat leider nicht funktioniert. Er darf nicht dazu dienen, ein normales Ergebnis mitzuteilen. Um den Gedanken zu verdeutlichen, betrachte man die Deklaration einer SQL-Verbindungen:</p><pre><code>type SQL interface {\n  Query(statement string) (*Result, error)\n}\n</code></pre><p>In welchem Fall wäre es vertretbar, einen <code>error</code> zu nutzen? Unzweifelhaft wäre es in dem Fall korrekt, dass die Verbindung zur Datenbank abbricht. Ein solcher Fall ist nicht nur intuitiv ein Ausnahmefall, er führt auch dazu, dass der Zweck der Methode vereitelt wird. Manchmal nutzen Entwickler aber auch ein <code>error</code>-Objekt, um mitzuteilen, dass das Ergebnis leer ist, weil keine Zeile der Datenbank die Bedingungen der Where-Clause erfüllt. In diesem Fall konnte die Methode aber einwandfrei ausgeführt werden, es liegt also gar kein Fehler vor. Hier dennoch einen <code>error</code> zu verwenden, erschwert nachfolgenden Entwicklerinnen und Entwicklern das Verständnis des Programmablaufs und sollte daher vermieden werden.</p><p>Alternativ zu <code>error</code>-Werten lassen sich in Go Booleans als Rückgabewerte nutzen, falls neben dem primären Ergebnis noch eine Information zu seinem Entstehen gewünscht ist. Beispiele dafür finden sich etwa bei Zugriffen auf <code>map</code>: <code>obj, ok := m[key]</code>. Hier zeigt der Wert der Variablen <code>ok</code> (bool) an, ob ein Objekt in der Map vorhanden war oder erst erzeugt wurde. Es wäre irreführend, hier einen <code>error</code> zu verwenden.</p><p>Ein weiterer Grund für die Bevorzugung von <code>bool</code> über <code>error</code> liegt im Laufzeitverhalten. Denn wenngleich auf die Fehlererstellung in Go schnell und mit fixen Kosten verbunden sein soll, gibt es doch erhebliche Unterschiede gegenüber der Verwendung von Booleans. In einem kurzen Benchmark habe ich beide Varianten einander gegenübergestellt. Dazu habe ich in jeweils einer Funktion einen Zufallswert (über <code>rand.Uint32</code>) erstellt und geprüft, ob er durch 2 teilbar ist. In einem Fall gab ich einen boolschen Wert zurück in Abhängigkeit von der Teilbarkeit, im anderen Fall einen <code>error</code> (wobei der <code>error</code> einen einfachen String verwendete und nicht auf teure Funktionen wie <code>fmt.Sprintf</code> zurückgriff). Außerdem zog ich noch das beliebte Substitut für natives Error-handling in Go heran: <code>github.com/pkg/errors</code>. In einem vierten Szenario habe ich nur den Test auf Teilbarkeit laufen lassen, um die Grundkosten zu ermitteln. Das Ergebnis war folgendes:</p><!--kg-card-begin: html--><table>\n<thead>\n<tr>\n<th style=\"text-align: left\">Test</th>\n<th style=\"text-align: right\">Iterationen</th>\n<th style=\"text-align: right\">ø-Dauer pro Iteration</th>\n<th style=\"text-align: right\">Differenz zur Basis</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left\"><code>error</code></td>\n<td style=\"text-align: right\">21176719</td>\n<td style=\"text-align: right\">50.22 ns/op</td>\n<td style=\"text-align: right\">37.54 ns</td>\n</tr>\n<tr>\n<td style=\"text-align: left\"><code>boolen</code></td>\n<td style=\"text-align: right\">47823517</td>\n<td style=\"text-align: right\">24.34 ns/op</td>\n<td style=\"text-align: right\">1.66 ns</td>\n</tr>\n<tr>\n<td style=\"text-align: left\"><code>github.com/pkg/errors</code></td>\n<td style=\"text-align: right\">1756707</td>\n<td style=\"text-align: right\">655.9 ns/op</td>\n<td style=\"text-align: right\">633.22 ns</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">Vergleichbasis</td>\n<td style=\"text-align: right\">51298843</td>\n<td style=\"text-align: right\">22.68 ns/op</td>\n<td style=\"text-align: right\">–</td>\n</tr>\n</tbody>\n</table><!--kg-card-end: html--><p>Die Vergleichsbasis dient hier dazu, zu ermitteln, wie lange die Erstellung des Zufallswertes, die Modulo-Operation etc. benötigen, die Differenz zeigt dann die durchschnittlichen Kosten für Funktionsaufruf und Rückgabe des Ergebnisses an. Das Ergebnis ist eindeutig, die Verwendung eines <code>error</code>-Objekts braucht mit durchschnittlich knapp 38 Nanosekunden mehr als 20 mal so lange, wie die Verwendung eines boolschen Wertes. Im Falle des beliebten <code>github.com/pkg/errors</code> haben wir eine Verschlechterung der Performance um den Faktor 380! Das wiederum liegt sicherlich daran, dass die <code>error</code>-Objekte in diesem Paket im Interesse der Nutzerfreundlichkeit gleich noch einen Callstack bekommen, was allerdings die Kosten in Abhängigkeit zur Tiefe des Stacks steigen lässt. Damit sollte auch aus dieser Perspektive klar sein, dass Fehler nur in Ausnahmefällen genutzt werden sollten.</p><h2 id=\"ignoriere-keine-fehler\">Ignoriere keine Fehler</h2><p>Sobald wir uns den letzten Punkt verinnerlicht haben und die Verwendung von <code>error</code>-Objekten auf die Fälle eines Fehlschlagens eines Funktionsaufrufs beschränken, ergibt sich die nächste Regel quasi von selbst: <strong>Ignoriere keine Fehler!</strong> In Sprachen mit Exceptions ist es nicht ganz so leicht, Fehler zu ignorieren, denn dazu muss eine Exception erstmal aktiv gefangen werden. In Go hingegen muss gar kein Code geschrieben werden, um einen Fehler einfach unbeachtet verschwinden zu lassen.</p><p>Es gibt mehrere mögliche Erwartungshaltungen, aus denen heraus Entwickler Fehler ignorieren:</p><ol><li>Ein Fehler kann an dieser Stelle gar nicht auftreten.</li><li>Ein Fehler kann hier auftreten, ist aber nicht relevant oder lässt sich ohnehin nicht sinnvoll behandeln (das kommt v.a. während des Shutdowns vor).</li></ol><p>Im ersten Fall müssen wir uns dann natürlich fragen, warum die aufgerufene Funktion einen <code>error</code> in ihrer Signatur trägt, wenn er doch gar nicht auftreten kann. Im zweiten Fall sollten wir uns die Frage stellen, warum wir eine Funktion aufgerufen haben, wenn uns gar nicht interessiert, ob sie ihre Aufgabe erfüllen konnte.</p><p>Das wesentliche Problem daran ist, dass bei einer späteren Überarbeitung aufgrund geänderter Anforderung oder aufgetretener Bugs ein anderer Entwickler Schwierigkeiten haben wird, die Intention zu verstehen. Vor kurzem war ich selbst in einer Anwendung auf der Suche nach der Ursache eines Bugs auf eine Vielzahl ignorierter Fehler gestoßen. Nachdem ich mich zunächst entschied, diese Fehler zumindest im Log zu protokollieren, sah ich, dass einige davon temporär sehr oft vorkamen. Leider war es extrem schwer, in Einzelfällen zu entscheiden, ob das vielleicht die Ursache des Bugs war oder etwas, was der vorherige Entwickler einfach als irrelevant einplante. Wie sich herausstellte, waren die meisten Fehler bewusst ignoriert worden, was die Wartbarkeit des Source Codes massiv einschränkte. Denn wie soll ein anderer Entwickler zwischen relevanten und irrelevanten Fehlern unterscheiden? Eine solche Unterscheidung ist nur unter Berücksichtigung umfangreicher Kontextinformationen möglich: Wann wird diese Funktion aufgerufen? Welche Rahmenbedingungen werden zuvor an ganz anderer Stelle herbeigeführt? Was geschieht innerhalb der aufgerufenen Funktion? Gab es vielleicht eine Teamabsprache, in diesem Fall einen Absturz oder einen Datenverlust zu riskieren? Man sieht schnell, wie das Verständnis erschwert wird.</p><p>Oft deutet ein Ignorieren von Fehlern darauf hin, dass in der aufgerufenen Funktion das <code>error</code>-Konstrukt missbraucht wird. Wenn möglich, sollte dann die aufgerufene Funktion überarbeitet oder zunächst das Vorliegen entsprechender Vorbedingungen geprüft werden. Das Ziel muss auch die <strong>Expressivität</strong> sein: Nachfolgende Entwicklerinnen und Entwickler müssen schnell erkennen können, wann ein Programmablauf korrekt funktioniert.</p><h2 id=\"reichere-fehler-im-bubbling-mit-hilfreichen-informationen-an\">Reichere Fehler im Bubbling mit hilfreichen Informationen an</h2><p>Wir kommen nun zu unserem Einstiegsszenario: Weniges ist dem Assignee eines Bugtickets unnützer als ein Kibana voller Logs mit dem Inhalt \"timeout\" ohne nähere Angabe, welche Operation denn abgebrochen weden musste, wodurch sie aufgerufen werden musste, mit welchen Parametern etc. pp. Meine Maxime heißt daher: <strong>Wird ein Fehler aus einer untergeordneten Funktion an eine übergeordnete Funktion durchgereicht, sollen genau diejenigen relevanten Kontextinformationen hinzugefügt werden, über die die aufrufende Funktion nicht verfügt.</strong></p><p>Vielleicht wünscht man sich zunächst einen Callstack, um die Entstehung des Fehlers eruieren zu können. Wer mit entsprechenden Callstacks in PHP oder Java Erfahrung gesammelt hat und bereits versuchte, hilfreiche Informationen aus mehreren Metern Call-Stack-Beschreibung zu extrahieren, weiß auch um die Grenzen dieses Konzepts. Das Grundproblem ist, dass das Programm nicht automatisch die relevanten Informationen als solche erkennen und ausgeben kann.</p><p>Die Best Practice in Go geht daher einen anderen Weg, der die Qualität der Informationen verbessert: Statt automatisch den Callstack zu nutzen, wird der Fehler in jeder Funktion mit weiteren Informationen angereichert und an die aufrufende Funktion weitergegeben. Dazu wird der ursprüngliche Fehler in ein neues <code>error</code>-Objekt eingebunden, etwa mit Hilfe der Funktion <code>Errorf</code> aus dem Paket <code>fmt</code>:</p><pre><code>func DoStuff(param string) error {\n ...\n if err := receiveSomething(calculatedValue); err != nil {\n   return fmt.Errorf(\"could not receive information with value %s: %w\", calculatedValue, err)\n }\n ...\n}\n</code></pre><p>Zwei Dinge sind in diesem Beispiel zu sehen:</p><ol><li>Dem weitergereichten <code>error</code>-Objekt wurde <code>calculatedValue</code> mitgegeben, aber nicht <code>param</code>. Das liegt daran, dass die aufrufende Funktion <code>param</code> kennt und ihr diese Information nicht gegeben werden muss. Andernfalls ist es wahrscheinlich, dass <code>param</code> von mehreren Funktionen in das <code>error</code>-Objekt geschrieben wird.</li><li>Obwohl <code>err</code> das <code>Stringer</code>-Interface implementiert, wird in <code>Errorf</code> nicht <code>%s</code> verwendet, sondern <code>%w</code>. Das hat zur Folge, dass der Fehler im neuen Fehler als Objekt erhalten bleibt und nicht nur seine Fehlermeldung Teil der neuen Fehlermeldung wird. Im Anschluss wird es möglich sein, mittels der Methode <code>Unwrap() error</code> auf den Ursprungsfehler zurückzugreifen.</li></ol><p>Was natürlich generell vermieden werden sollte, ist ein Ignorieren des Fehlerursprungs:</p><pre><code>  ...\n  res, err := fnt()\n  if err != nil {\n    return errors.New(\"operation failed, probably some network trouble\")\n  }\n  ...\n</code></pre><p>Leider sieht man sowas nur allzu oft, im Zweifel kann es äußerst irreführend sein. Deshab ergänze ich das Prinzip der Informationsanreicherung durch den Grundsatz, dass Informationen niemals verworfen werden dürfen.</p><p>Wird dies eingehalten, dann ergeben sich informative Logmeldungen, die etwa so aussehen:</p><pre><code>2023-01-15 11:02:13.1261 fetching config information failed: could not fetch ETCD information for key 'my-app': could not dial 162.123.154.2: connect timeout\n</code></pre><p>Nun lässt sich mit einem Blick sehen, was passiert ist und warum es passiert ist. Genau das ist der Vorteil des expliziten Anreicherns von Informationen in Go, wenn wir uns an den oben aufgestellten Grundsatz halten.</p><h1 id=\"noch-ein-paar-technische-details\">Noch ein paar technische Details</h1><p>Das waren die grundlegenden Prinzipien, die uns helfen sollten, besser mit auftretenden Fehlern umzugehen. Abschließend möchte ich noch auf ein paar technische Details eingehen, die dabei helfen.</p><h2 id=\"wrapping-und-eigene-error-objekte\">Wrapping und eigene <code>error</code>-Objekte</h2><p>In dem Beispiel hatte ich <code>fmt.Errorf</code> verwendet und <code>%w</code> statt <code>%s</code> oder <code>%v</code> als Platzhalter für den Ursprungsfehler verwendet. Dies hat den Vorteil, dass nicht nur ein neuer <code>error</code> erstellt, sondern der Ursprungsfehler in den neuen Fehler eingebunden wird. Mittels <code>Unwrap()</code> kann dann aus dem neuen Fehler auf den alten Fehler zurückgegriffen werden. Seit Version 1.20 ist es auch möglich, mehrere Fehler durch <code>errors.Join(errs ...error) error</code> in einen einzigen Fehler zu wrappen. Sicherlich war dies zuvor auch mit Standardmitteln möglich (und es gab auch verbreitete Packages, die dies ermöglichten). Hilfreich ist außerdem, dass <code>Unwrap</code> nun auch ein <code>error</code>-Slice zurückgeben kann und dies an den entsprechenden Stellen der Standardbibliothek berücksichtigt wird.</p><p>Wenn wir einen Fehler behandeln wollen, ist es oft wichtig zu wissen, um was für eine Art von Fehler es sich handelt. Schlägt ein HTTP-Request fehl und die Ursache ist ein Timeout, dann mag es vernünftig sein, den Request noch einmal zu senden. Lautet der Fehler jedoch, dass der Request selbst fehlerhaft sei (<code>400 Bad Request</code>), dann kann auch ein erneuter Versuch keinen Erfolg bringen. Um solche Unterscheidungen zuverlässig treffen zu können, ist es in Sprachen mit Exceptions üblich, keine Exception-Typen zu definieren, die von nativen Exception-Typen abgeleitet werden (bspw. von <code>std::runtime_exception</code> in C++). Viele Linter kreiden sogar die Verwendung nativer Exception-Typen als Code Smell an und fordern Entwicklerinnen und Entwickler zur Implementierung eigener konkreter Exceptions auf.</p><p>Go verfügt zwar nicht über das Konzept der Ableitung, aber wir hatten bereits gesehen, dass etwas nur das <code>error</code>-Interface und damit die Methode <code>Error() string</code> implementieren muss, um als Fehler in Go zu zählen. Wir können also unser Timeout einfach mit einem eigenen Fehlertypen versehen und anschließend das seit Go 1.13 vorhandene <code>errors.As</code> verwenden, um einen Fehler auf einen konkreten Fehlertypen zu prüfen (oder auch <code>errors.Is</code> zur Prüfung auf Gleichheit von Typ und Inhalt):</p><pre><code>type Timeout struct {\n  msg string\n}\nfunc (t *Timeout) error {\n  return t.msg\n}\n\nfunc doStuff() error {\n  ...\n  var cmp *Timeout\n  if errors.As(err, &amp;cmp) {\n    // retry\n\t  ...\n  } else {\n    return fmt.Errorf(\"operation %s failed: %w\", param, err)\n  }\n  ...\n}\n</code></pre><p>Dieses Vorgehen ist deutlich besser, als den Standard-<code>error</code> aus <code>errors.New</code> zu verwenden und dann die Fehlermeldung zu analysieren.</p><p>Nun kann es aber natürlich sein, dass unser Timeout-Objekt zwischendurch weitergleitet und dabei in ein anderes <code>error</code>-Objekt eingebunden wurde, beispielsweise mit <code>fmt.Errorf</code>. Die Funktion <code>errors.As</code> schafft es hier, auch mit Ursprungsfehlern zu vergleichen, insofern diese über eine Methode <code>Unwrap() error</code> (ab Version 1.20 auch <code>Unwrap() []error</code>) zugänglich sind. Wird ein Fehler mit <code>fmt.Errorf</code> aus einem anderen Fehler erstellt, dann hat der neue Fehler eine entsprechende Methode zum Zugriff auf den Ursprungsfehler und <code>errors.As</code> kann auch mit dem Ursprung vergleichen.</p><p>Man beachte, dass bei Funktionen bei inkorrekter Verwendung Panics auslösen und daher dringend getestet werden müssen. Ansonsten kann es zum Absturz der gesamten Anwendung kommen, wenn tatsächlich mal ein (ansonsten vielleicht harmloser) Fehler auftritt.</p><p>Bei der Erstellung eigener <code>error</code>-Typen gilt es daher, folgendes zu beachten: Ein <code>error</code>-Type, der auf andere Fehler regiert, sollte in aller Regel eine <code>Unwrap() error</code>-Methode haben, um Zugriffe auf den Urprungsfehler zu ermöglichen. In Fällen, in denen ein Zugriff auf den Ursprung explizit unerwünscht ist, sollte zumindest die Fehlermeldung Informationen über den Ursprungsfehler beinhalten. Dazu ist es oft hilfreich, das Formatter-Interface zu implementieren.</p><h1 id=\"zusammenfassung\">Zusammenfassung</h1><p>Die Fehlerbehandlung in Go ist gewöhnungsbedürftig und oft auch etwas umständlich. Es gibt viele Situationen, in denen ich Exceptions ernsthaft vermisse und die Möglichkeiten von Go für unzureichend halte. Vielleicht ist es tatsächlich das nächste entscheidende Thema nach den Generics, an dem sich die weitere Entwicklung der Sprache entscheiden wird.</p><p>Der Grundsatz, Fehler nicht zu ignorieren, hat in Go zur Folge, dass unser Code sehr explizit und mitunter unleserlich werden kann:</p><pre><code>  data, err := fnt()\n  if err != nil {\n    ...\n  }\n  if err = fnt2(data); err != nil {\n    ....\n  }\n  ...\n</code></pre><p>Das möchte ich gar nicht beschönigen. Ein so explizites Vorgehen wird schnell unübersichtlich und lenkt von der eigentlichen Programmlogik ab. Es existieren inzwischen mehrere Vorschläge, Go mit einem sprachlichen Konstrukt (<code>try</code> oder <code>check</code>) auszustatten, das die Fehlerbehandlung weniger umständlich macht (siehe dazu auch die <a href=\"https://entwickler.de/go/netter-versuch\">Sicht von Frank Müller</a>). Bis sich eine Lösung findet, bleibt hier möglicherweise ein Manko der Sprache bestehen. Dem Entwickler hilft natürlich kein Jammern und daher gilt es, die vorhandenen Sprachmittel (z.B. Lambdas) zur Vereinfachung zu nutzen. Die Community kommt bisher schließlich durchaus gut ohne weitere sprachliche Mittel aus.</p><p>Die Einfachheit hat schließlich auch entscheidende Vorteile (und Exceptions haben erhebliche Nachteile), so dass es sich lohnt, sich einmal auf das Konzept einzulassen. Ohnehin bleibt einem als Go-Entwickler aktuell nichts anderes übrig, als das Beste aus der Situation zu machen. Im vorhergehenden glaube ich die Grundprinzipien beschrieben zu haben, an denen wir uns dafür orientieren sollten.</p>","comment_id":"640b415973c6dcb1f2fbd1dd","feature_image":"https://blog.alexandergunkel.eu/content/images/2023/03/error-logs.png","featured":false,"visibility":"public","created_at":"2023-03-10T15:40:25.000+01:00","updated_at":"2023-03-10T16:12:37.000+01:00","published_at":"2023-03-10T16:12:37.000+01:00","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"url":"https://blog.alexandergunkel.eu/error-handling-in-golang/","excerpt":"Go geht an einigen Stellen recht eigene Wege und dies gilt insbesondere auch für den Umgang mit Fehlern, in dem sich Go sowohl von dem Konzept der Exceptions wie in Java, C++ oder PHP distanziert, als auch einen anderen Weg als C mit seinen Error-Codes, wie sie auch in C++ noch verwendet werden. Dabei scheint mir der Umgang mit Fehlern in Go durch drei Prinzipien geprägt zu sein:\n\n 1. Fehler sind keine außergewöhnlichen Geschehnisse, sondern ein ganz normaler Vorgang in Softwareprogrammen, also ","reading_time":13,"access":true,"comments":false,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":"Error Handling in Golang","meta_description":"Go hat ein eigentümliches Error-Handling, das Umsteigern aus anderen Sprachen Probleme bereitet. Hier beschreibe ich hilfreiche Prinzipien.","email_subject":null,"frontmatter":null,"feature_image_alt":null,"feature_image_caption":null},{"id":"63f73aca73c6dcb1f2fbd19a","uuid":"abe451de-e3f2-40c9-9450-af1f892129d8","title":"Was ist Go und warum gehört Googles Sprache zu meinen Backend-Favoriten?","slug":"was-ist-go-und-warum-ist-es-einer-meiner-backend-favoriten","html":"<p>Mich persönlich reizte die Sprache Go bereits vor vielen Jahren als Junior Entwickler, der damals noch in einer Leipziger Agentur mit PHP im Backend arbeitete. Googles neue Sprache versprach eine niedrige Einstiegshürde und schnelles Entwickeln produktiver Anwendungen bei exzellenter Performance, Robustheit und Qualität. Heute sehe ich diese Punkte bestätigt und zähle Go zu den besten Programmiersprachen für Backendanwendungen im Webbereich.</p><h1 id=\"laufzeitverhalten\">Laufzeitverhalten</h1><p>Als ersten Punkt gilt es festzuhalten: Go verügt über ein <strong>exzellentes Laufzeitverhalten</strong>, die Performance spielt in vielen Belangen in der Liga von C und C++. Und vor allem entspricht das Startverhalten auch dem, was wir von C oder C++ kennen, da der Code statisch kompiliert in Binaries vorliegt und keine VM gestartet werden muss. Auch hat Go einen recht <strong>geringen Speicherbedarf</strong>, was die Sprache ebenfalls zu einer guten Alternative zu C und C++ macht. Lediglich der Garbage Collector kann gelegentlich zu den bekannten Verzögerungen führen, die aber in sehr vielen Anwendungsfällen nicht relevant sein werden.</p><h1 id=\"einfachheit\">Einfachheit</h1><p>Worin sich Go grundlegend von C und vor allem auch von C++ unterscheidet, das ist die <strong>Einfachheit der Sprache</strong>: So reduziert der Verzicht auf funktional redundante Sprachmittel (z.B. einmal <code>for</code> statt <code>while…do</code>, <code>do…while</code>, <code>foreach</code>) die Sprache schon ganz erheblich. Go kennt zwar Pointer, aber keine Pointer-Arithmetik. Es sind keine Überladungen möglich und es gibt auch nicht das in C++ berüchtigte Undefined Behaviour. Ganz allgemein zeichnet sich Go auch durch einen Verzicht auf die klassischen Sprachmittel der Objektorientierung aus. So gibt es keine Klassen, sondern nur Strukturen, die Kapselung von Daten ist nicht auf der Ebene der Strukturen, sondern der Module (packages) möglich. Go setzt auf <strong>Komposition statt Vererbung</strong>, was so manchen architektonischen Fehler von vornherein ausschließt.</p><p>Go verfügt über einen <strong>Garbage Collector</strong>, der Entwickler von rein technischen Überlegungen entlastet und so ermöglicht, dass wir uns auf das Wesentliche konzentrieren. <strong>Polymorphie</strong> wird möglich über Interfaces mit dynamischer Bindung an konkrete Implementierung zur Laufzeit (<strong>Ducktyping</strong>). Eine Struktur kann dadurch ein Interface implementieren, ohne von ihm zu wissen. Das macht <strong>lose Kopplung</strong> (<em>loose couling</em>) kinderleicht, da es von architektonischer Vorsicht entlastet. Beides kommt aber mit einer gewissen Einschränkung: Denn auch in Go sind Heap-Allokationen und Polymorphie nicht kostenfrei zu haben; sie wirken sich durchaus auf das Laufzeitverhalten aus. Wer eine hochperformante Applikation erstellen möchte, wird beides reduzieren und eine ähnliche Sorgfalt an den Tag legen müssen, wie dies in C++ auch der Fall ist.</p><h2 id=\"generics\">Generics</h2><p>Was mir lange ein Dorn im Auge war, das war die Unmöglichkeit generischen Programmierens, die erst nachträglich mit Version 1.19 und nach langer Diskussion in der Form von <strong>Generics</strong> eingeführt wurde. Der Streitpunkt war recht klar: Wenn die Sprache generisches Programmieren ermöglichen soll, dann steigt die Dauer des Kompilierens oder die Ausführungszeit – je nach Art der Umsetzung. Und wer C++ und seine Metaprogrammierung aus großen Projekten kennt, der weiß auch um die Gefahren, die durch übermäßig generische Ansätze dort lauern. Gutes generisches Programmieren erfordert viel Sorgfalt. Golang soll aber auch ohne große Sorgfalt geschriebenen Code beherrschbar halten. Stattdessen wurde daher zunächst auf Reflection gesetzt. Ich halte die Entscheidung, Generics und damit eine Art Meta-Programming einzuführen, für goldrichtig. Reflection ist nicht nur deutlich komplizierter und außerdem zur Laufzeit langsamer. Reflection ist auch unleserlich und führt genau zu dem Effekt, der vermieden werden sollte: Sie lenkt von der eigentlichen Aufgabe ab und flutet den Code mit technischen Details aus der Sprache, die nur für Eingeweihte verständlich sind. Generisches Programmieren bietet hingegen die Möglichkeit, <strong>kurz, prägnant und expressiv</strong> zu sein. Letzteres ist ja beispielsweise der Vorteil der Algorithmen in der Standard-Template-Library von C++.</p><h2 id=\"tooling\">Tooling</h2><p>Zu den Vereinfachungen, die einen erheblichen Impact auf ein gutes Ergebnis und qualitativ hochwertigen Code haben, gehören die von Haus aus mitgelieferten Werkzeuge für <strong>Test- und Benchmark-Frameworks</strong>. Damit entfällt eine weitere Ausrede, Code ohne Unit-Tests zu schreiben oder die Performance-Optimierung ohne empirische Unterfütterung zu betreiben. Neuerdings unterstützt Go sogar nativ <strong>Fuzz-Tests</strong>, also die Ausführung von Test-Szenarien mit zufällig variierten Eingaben, um unentdeckte Schwachstellen und Bugs zu finden. Von einigen berüchtigten Sicherheitslücken der letzten Jahre ist bekannt, dass Fuzz-Testing sie zuverlässig verhindert hätte (siehe als Beispiel den Fall <a href=\"https://forallsecure.com/blog/the-fuzzing-files-the-anatomy-of-a-heartbleed\">Heartbleed</a>). Ein leicht zu aktivierender <strong>Race-Detector</strong> macht auf Fehler in der nebenläufigen Programmierung aufmerksam.</p><p>Aus meiner Erfahrung nicht zu unterschätzen ist auch, dass die Entwickler von Go sich für eine <strong>einheitliche Formatierung</strong> als globale Vorgabe entschieden und den passenden Formatter gleich mitgeliefert haben. Ich weiß nicht, wie viele Stunden ich bereits in Diskussionen über Umbrüche, Einrückungen und Whitespaces verbracht habe. Was ich sicher weiß ist, dass jede dieser Stunden eine zuviel war.</p><h1 id=\"aktualit%C3%A4t\">Aktualität</h1><p>Als recht junge Sprache enthält Go native Unterstützung für die Dinge, die heute oft benötigt werden, etwa für <strong>Nebenläufigkeit</strong> mit Goroutines, Channels und eingebautem Race-Detector. Channels ermöglichen Nebenläufige Programmierung im Pipeline-Stil. In anderen Sprachen ist sowas mitunter aufwendig zu implementieren und bedarf oft weiterer Bibliotheken. Interessant ist die <strong>native Unterstützung von Netzwerkkommunikation</strong> über TCP. Leicht implementierbare Schnittstellen vereinfachen die Erstellung lose gekoppelter Services. Golang ist für den Einsatz in <strong>Microservices</strong> hervorragend geeignet und damit für <strong>skalierbare Netzwerkdienste</strong>, für <strong>Cloud-Computing</strong> und <strong>Cluster-Computing</strong>.</p><h1 id=\"leichte-handhabbarkeit-einfaches-deployment\">leichte Handhabbarkeit, einfaches Deployment</h1><p>Einem Mythos zufolge entstand das Konzept zu Go bei Google in der Zeit, in der einziges C++-Projekt kompiliert wurde, als Reaktion auf die langen Zwangspausen in Folge klassischer Build-Prozesse. Und eines ist ganz offensichtlich gelungen: Bei kaum einer kompilierten Sprache ist der Buildprozess so schnell wie bei Go. Hinzu kommt die <strong>einfache und einheitliche Einbindung von Abhängigkeiten</strong>. In derselben Zeit, in der ich in C++ GoogleTest mit Cmake eingebunden habe, kann ich in Go fast schon einen ersten Prototypen erstellen, zumindest aber den ersten Unit-Test schreiben.</p><p>Go-Projekte kompilieren zu je einem einzelnen Executable, das keine komplizierte Anbindung an dynamisch gelinkte Bibliotheken und auch keine virtuelle Maschine benötigt. Damit ist das Deployment so einfach, dass sich die Containerisierung oft erübrigt. Im Vergleich zu einem C++-Projekt lassen sich da schnell mehrere Entwicklertage einsparen.</p><p>Der <strong>ultraschnelle Build-Prozess</strong> und das <strong>leichte Deployment</strong> machen Go auch zu einer Alternative für Scriptsprachen wie PHP. Denn bisher ist ein wesentlicher Vorteil von PHP, dass damit sehr schnell Prototypen erstellt und ausgerollt und auch Korrekturen ebenso schnell verfügbar gemacht werden können.</p><h1 id=\"sicherheit\">Sicherheit</h1><p>Gerade wer bisher mit dynamisch typisierten oder nicht typisierten Sciptsprachen arbeitete, bemerkt schnell die <strong>Strenge der statischen Typisierung</strong> in Go. Jede Typumwandlung muss in Go explizit gemacht werden, nirgends wird implizit etwa aus einem <code>uint64</code> ein <code>uint32</code>. Was manchen PHP-Entwicklern zunächst schwerfallen mag, ist letztlich ein Segen, denn es vermeidet häufige Fehlerquellen und schwer zu interpretierenden Code, in dem niemand sagen kann, welche Variable zur Laufzeiten Daten welchen Typs beinhalten wird.</p><p>Eine Besonderheit ist die Möglichkeit der Deklaration abgeleiteter Typen, die im Gegensatz zu den <code>typedef</code>- oder <code>using</code>-Deklarationen in C++ keine bloßen Aliase darstellen, sondern eigene Datentypen. Damit kann bereits der Compiler Verwechslungen bei der Variablenzuordnung ausschließen. In C++ gibt es dafür das Konzept der <strong>Strong-Types</strong>, das jedoch einer eigenständigen Implementierung bedarf (siehe dazu etwa <a href=\"https://github.com/alexgunkel/strongtypes\">github.com/alexgunkel/strongtypes</a>).</p><p>Gegenüber C und C++ erweist es sich als Sicherheitsgewinn, dass das Speichermanagement nicht mehr von den Entwicklerinnen und Entwicklern übernommen werden muss, sondern ein <strong>Garbage Collector</strong> den allokierten Heap-Speicher wieder freigibt. Auch die berüchtigten Dangling References sind in Go ausgeschlossen, da sich auch hier die Speicherverwaltung um die korrekte Lifetime der Entitäten kümmert. Ein weiteres Sprachmittel wird Menschen, die bereits mit C++ gearbeitet haben, schnell vertraut sein: <code>defer</code> als Substitut für RAII ist ein wichtiges Pendant zum Speichermanagement, das die Ausführung einer Funktion beim Verlassen einer sie umgebenden Funktion garantiert. Es führt damit eine Garantie im Rahmen des Stack Unwinding ein ähnlich der Garantie in C++, den Destruktor eines jeden Objekts zum Ende seiner Lifetime auszuführen. Wichtig ist dies insbesondere zur Vermeidung von Resourcenlecks, denn der Speicher ist nur eine, nicht die einzige Quelle solcher Bugs.</p><h1 id=\"eigensinnige-fehlerbehandlung\">Eigensinnige Fehlerbehandlung</h1><p>Etwas eigensinnig ist der Umgang mit zur Laufzeit auftretenden Fehlern. Man denke hier etwa an abbrechende Netzwerkverbindungen, zu geringen Speicherplatz oder unerwartete Nutzereingaben.</p><p>Bekanntlich verwendet Go ganz bewusst <strong>keine Exceptions</strong>, da Fehler keine Ausnahmesituationen in Programmabläufen seien, sondern ganz normaler Bestandteil von Programmabläufen. Als Ersatz für Exceptions verfügt Go über ein anderes, sehr interessantes Feature: <strong>Multiple Rückgabewerte</strong> erlauben es, sehr einfach ein Ergebnis von einem aufgetretenen Fehler sauber zu trennen, ohne auf Konstrukte wie Output-Parameter zurückgreifen zu müssen (wie in C üblich). Mehr zu diesem Thema gibt es demnächst hier in einem eigenständigen Text zur Fehlerbehandlung in Go.</p><h1 id=\"fazit\">Fazit</h1><p>In Go wird verhindert, dass Entwickler versuchen, zu clever zu sein. Das ist sicherlich ein großer Vorteil der Sprache. Von Anfang an war es auch ein Ziel, dass Entwickler keinen großen Schaden im Projekt anrichten können, indem beispielsweise auf Vererbung und Funktionsüberladung verzichtet wurde, also auf Sprachmittel, die die Wartbarkeit einer Applikation bei falscher Anwendung schnell einschränken. Dadurch ist Go auch für Teams mit sehr unterschiedlichem Erfahrungs- und Kenntnisstand sehr gut geeignet, was in der heutigen Softwareentwicklung die Regel ist. Schon dadurch sollte Golang verstärkt in Betracht gezogen werden.</p><p>Vieles an der Sprache ist neu und erfordert von Entwicklerinnen und Entwicklern ein Umdenken und Anpassen vertrauter Strategien. Wer aus einer OOP-Sprache kommt und an Exceptions gewöhnt ist, muss sich auf Kapselung auf Modulebene und eine völlig andere Fehlerbehandlung einstellen. Aus meiner Sicht ist dieser Punkt nicht zu unterschätzen, denn die oft gepriesene Einheitlichkeit und Qualität ist mitnichten ein Selbstläufer. Es braucht motivierte Entwicklerinnen und Entwickler, die bereit sind, sich auf eine manchmal eigenwillige Sprache einzulassen und idiomatische Wege zu finden. Für solche Menschen bietet Go die Möglichkeit, sich voll und ganz auf die Aufgabe zu konzentrieren und mit wenig Ablenkung durch Finessen robuste, performante und wartbare Software zu entwickeln.</p><p>Go lässt sich auf allen gängigen Systemen kompilieren und ist letztlich für alles geeignet, was auf einem Server läuft. Für Webapplikationen ist Go inzwischen fester Bestandteil meines favorisierten Tech-Stacks, der sich primär aus einem reaktiven Typescript-Framework im Frontend und einer Kombination aus Go und C++ im Backend zusammensetzt. Damit wird es leicht, eine kurze Entwicklungszeiten mit hoher Qualität und Sicherheit sowie herausragender Performance zu verbinden.</p>","comment_id":"63f73aca73c6dcb1f2fbd19a","feature_image":"https://blog.alexandergunkel.eu/content/images/2023/02/Go_gopher_app_engine_color.jpg","featured":false,"visibility":"public","created_at":"2023-02-23T11:07:06.000+01:00","updated_at":"2023-03-06T15:15:51.000+01:00","published_at":"2023-02-23T11:15:31.000+01:00","custom_excerpt":"Warum Go zu den besten Programmiersprachen für Backendanwendungen im Webbereich gehört.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"url":"https://blog.alexandergunkel.eu/was-ist-go-und-warum-ist-es-einer-meiner-backend-favoriten/","excerpt":"Warum Go zu den besten Programmiersprachen für Backendanwendungen im Webbereich gehört.","reading_time":6,"access":true,"comments":false,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"email_subject":null,"frontmatter":null,"feature_image_alt":"Der Gopher, das Maskottchen von Golang","feature_image_caption":"Renee French, CC BY 3.0 &lt;https://creativecommons.org/licenses/by/3.0&gt;, via Wikimedia Commons"},{"id":"63b2758b5a5098039e541c19","uuid":"5f8261c9-6e7f-4626-9201-04d448293fbf","title":"Komplexität: die tägliche Herausforderung","slug":"komplexitat-die-tagliche-herausforderung","html":"<p>Der Umgang mit Komplexität ist die zentrale Herausforderung der meisten Softwareprojekte. Viele Projekte wachsen über die Jahre zu wahren Ungetümen an, deren Wartung immer schwieriger wird. Die Folgen sind oft beschrieben worden: Weitere Veränderungen werden fehleranfällig und dauern immer länger. Neue Kollegen brauchen zunehmend mehr Zeit, sich in den bestehenden Code einzuarbeiten.</p><h1 id=\"was-ist-eigentlich-komplexit%C3%A4t\">Was ist eigentlich Komplexität?</h1><p>Komplexität in dem hier beschriebenen Sinne entspricht nicht dem, was die Informatik zumeist unter dem Wort versteht, wenn über die Zeit- und Platzkomplexität von Algorithmen gesprochen wird. Sicherlich gibt es Zusammenhänge zwischen beiden Begriffen; aber das wäre ein ganz eigenes Thema. Es gibt weitere Kennzahlen, deren Bezeichnung sie als Kennwerte für Komplexität ausweisen: die zyklomatische Komplexität, die sich aus der Anzahl u.a. von Verzweigungen errechnet, und die Pfadkomplexität, die die Anzahl möglicher Wege durch eine Funktion beschreibt. Daneben gibt es weitere Kennzahlen für Komplexität. Meiner Erfahrung nach werden diese Kennzahlen aber eher selten in direkten Zusammenhang zu der von Entwicklerinnen und Entwicklern in ihrem Arbeitsalltag wahrgenommenen Komplexität gebracht. Sie erscheinen vielen Menschen nicht hinreichend relevant zu sein für diejenige Art von Komplexität, die uns tatsächlich beschäftigt.</p><p>Was aber ist dann der Sinn von Komplexität, um den es geht? Wir wissen zunächst, dass Komplexität das ist, was uns bei der Wartung und Weiterentwicklung Probleme bereitet. Ein System wird mit der Zeit komplex, wenn es durch neue Anforderungen, Anpassungen und Weiterentwicklungen wächst. Eine Anwendung hat beispielsweise als einfache Anwendung mit 500 Zeilen Source Code angefangen; fünf Jahre später arbeiten zehn Entwickler an mittlerweile 1.000.000 Zeilen Source Code. Die Komplexität ist über die Jahre enorm gestiegen. Aber die Anzahl der Code Zeilen (LOC – Lines of Code) ist kein Maß der Komplexität.</p><p>Ist denn dann die Anzahl der Objekte, Klassen, Strukturen oder Funktionen ein Maß der Komplexität? Es ist einfach zu sehen, dass die Anzahl irgendwelcher Objekte nicht ursächlich für Komplexität ist. Ein Sandhaufen besteht aus sehr vielen Objekten (Sandkörnern), ist aber nicht komplex. Ein Schaltkreis besteht dagegen in aller Regel aus viel weniger Objekten, ist aber komplex. Denn was Komplexität ausmacht, ist nicht die schiere Anzahl an Entitäten, sondern die Zahl der faktischen und potentiellen Verbindungen zwischen diesen Objekten. Das ist letztlich auch, was zyklomatische und Pfadkomplexität oder auch Maße für afferente und efferente Kopplungen versuchen in numerischen Werten abzubilden. Es geht um Spezifizierungen des Begriffs der Komplexität. Sie erscheinen uns manchmal irrelevant, weil sie zu speziell sind oder auch gerade die falsche Spezialisierung abbilden. In einem abstrakteren Sinne geht es einfach um die Anzahl und Übersichtlichkeit der möglichen und tatsächlichen Verbindungen zwischen irgendwelchen Dingen. Sind diese Verbindungen schwer zu durchschauen, dann macht uns dies das Leben als Entwickler schwer. Die Software ist dann komplex.</p><h1 id=\"l%C3%A4sst-sich-komplexit%C3%A4t-vermeiden\">Lässt sich Komplexität vermeiden?</h1><p>Es gibt eine ganz natürliche Reaktion auf das Problem der Komplexität: Vermeidung durch Zurückweisung zusätzlicher Anforderungen. Und das ist sicherlich auch nicht falsch. Bei jeder neuen Anforderung sollte bedacht werden, dass sie zusätzliche Komplexität in das Projekt einführt, die mit unvermeidbaren Folgekosten verbunden ist. Daher sollte neben dem Entwicklungsaufwand für die Anforderung selbst (also eine bestimmte Anzahl von Entwicklerstunden) auch der Sachverhalt in die Kosten-Nutzen-Abwägung einbezogen werden, dass dadurch erstens ein zusätzlicher dauerhafter Wartungsaufwand generiert wird und zweitens zukünftige Änderungen durch die höhere Ausgangskomplexität teurer werden.</p><p>Nichtsdestotrotz gehört es zu den Realitäten der Softwareentwicklung, das Anforderungen hinzukommen und die Komplexität der Projekte dadurch stetig erhöhen. Wenn wir uns erfolgreiche Softwareprojekte anschauen, etwa Google Suche oder Facebook, dann ist klar, dass sie eine erhebliche Komplexität aufweisen, die sich aus den Anforderungen an das jeweilige Produkt zwingend ergibt. Manche sprechen hier auch von essentieller Komplexität – im Unterschied zu akzidentieller Komplexität, also derjenigen Komplexität, die wir unnötigerweise durch schlechte Arbeit hinzufügen.</p><h1 id=\"wie-l%C3%A4sst-sich-komplexit%C3%A4t-beherrschen\">Wie lässt sich Komplexität beherrschen?</h1><p>Wir können also nicht vermeiden, uns mit der entstehenden (essentiellen) Komplexität zu arrangieren. Lasst uns also Wege finden, mit ihr umzugehen. Hier sind einige Ansätze:</p><h2 id=\"divide-et-impera-modularisierung-und-kapselung\">Divide et impera: Modularisierung und Kapselung</h2><p>Es ist das klassische Mittel im Kampf gegen die Folgen der Komplexität: die Aufteilung eines komplexen Systems in zwei oder mehr weniger komplexe Systeme. Der offensichtliche Effekt ist, dass wir bei guter Aufteilung zukünftig meist nur ein Teilsystem betrachten müssen, dessen Komplexität deutlich geringer ist. Was weniger offensichtlich ist: Modularisierung macht Komplexität nicht nur beherrschbarer, sie kann Komplexität in der Tat auch reduzieren.</p><p>Um das einzusehen, wollen wir eine sehr schematische Überlegung anstellen: Nehmen wir an, wir haben ein System mit zehn Entitäten (Klassen, Strukturen), die alle Verbindungen zueinander pflegen. Die Anzahl der Verbindungen ist dann <code>9 + 8 … + 1 = (9/2) * 10 = 45</code>. Wir können also 45 (die Zahl der Verbindungen zwischen je zwei Elementen) als Maß für die Gesamtkomplexität nehmen. Teilen wir nun das ganze in zwei Teile mit je fünf Elementen. Diese fünf gehen jeweils Beziehungen zu allen anderen Elementen in derselben Gruppe ein. Zusätzlich gehen beide Gruppen eine Verbindung zueinander ein. Die Gruppen haben eine jeweilige Einzelkomplexität von <code>4 + 3 + 2 + 1 = (4/2) * 5 = 10</code>, woraus sich eine Gesamtkomplexität von <code>10 + 10 + 1 = 21</code> ergibt. Das ist weniger als die Hälfte der Ausgangskomplexität. Und selbst wenn wir einen gewissen Overhead für die architektonische Umgestaltung annehmen und jeweils ein zusätzliches Element pro Gruppe hinzufügen, steigt die Komplexität nur auf 31, liegt also weiterhin deutlich unterhalb des Ausgangswertes.</p><p>Es geht aber nicht nur um die Vermeidung überflüssiger (akzidenteller) Komplexität, sondern auch darum, die anforderungsgetriebene essentielle Komplexität beherrschbar zu machen: durch <em>Kapselung</em> und <em>klare Strukturen</em>. Kapselung hat das Ziel, die Anzahl möglicher Verbindungen zu reduzieren. Die Zahl der möglichen unterschiedlichen Verbindungen wird dadurch reduziert, was die Komplexität verringert. Klare Strukturen ermöglichen uns ein besseres Verständnis, indem wir uns auf einen Teilbereich der Verbindungen konzentrieren und andere Verbindungen ausblenden können.</p><p>Wichtig ist bei der Strukturierung die Orientierung an Abstraktionsebenen. Jede Softwareeinheit (Klasse, Methode oder Funktion) sollte sich durchgängig auf einer ähnlichen Abstraktionsebene befinden. Es ist eine schlechte Idee, in ein und derselben Funktion abstrakte Businesslogik mit kleinteiligen Stringformatierungen und Speichermanagement zu verbinden. Gerade das sieht man aber häufig in Projekten, in denen die Komplexität zu einem ernsthaften Problem geworden ist. Für diejenigen, die solchen Code warten müssen, ist es dann deutlich schwieriger, die Struktur der Software zu erkennen.</p><h2 id=\"mut-zum-wandel-was-obsolet-ist-muss-weg\">Mut zum Wandel: Was obsolet ist, muss weg</h2><p>Wer viel mit großen Projekten zu tun hatte, wird es kennen: Man stößt auf Passagen im Source Code, bei denen niemand auf Anhieb sagen kann, ob und wenn ja wozu sie eigentlich noch verwendet werden. Bei vielen Projekten, die ich kennenlernen durfte, waren beträchtliche Teile der Anwendung überhaupt nicht mehr in Verwendung. Dennoch trugen sie erheblich zur Steigerung der Komplexität bei. Da wurde etwa eine alte API durch eine neue API abgelöst, die alte aber \"zur Sicherheit\" noch im Code behalten; es könnte ja die Notwendigkeit eines Zurückschwenkens eintreten. Zumeist ist dies eine trügerische Hoffnung: Wenn die alte API nicht mehr verwendet wird, dann wird sie auch nicht mehr gepflegt und die Chancen, dass sie tatsächlich noch zuverlässig funktioniert, schwinden. Das Wissen um ihren Ursprung schwindet ebenso und irgendwann weiß niemand mehr, aus welchem Grund sich die Code-Abschnitte noch im Repository befinden. Wer früh und konsequent alte Zöpfe abschneidet, vermeidet solche unnötige Komplexität und verringert den zukünftigen Wartungsaufwand.</p><h2 id=\"kiss-oder-besser-strive-for-simplicity\">KISS oder besser: Strive for Simplicity</h2><p>Keep it simple and stupid (KISS) gehört zu den bekannteren Prinzipien der Softwareentwicklung. Es ist allerdings ein Prinzip mit dem ich zugegebenermaßen meine Schwierigkeiten habe, denn es suggeriert, dass Einfachheit etwas ist, was mühelos (quasi naturgegeben) am Anfang steht. Dabei ist Einfachheit in aller Regel nicht der leicht erreichbare Ausgangspunkt, sondern das späte Ergebnis umfangreicher Mühen und gedanklicher Anstrengungen.</p><p>Menschen tendieren dazu, Änderungen primär über das Hinzufügen weiterer Teile vorzunehmen. Das ist mitnichten nur ein Phänomen der Softwareentwicklung, sondern fast schon so etwas wie eine anthropologische Konstante. Wir kennen das auch von Gesetzen oder Verwaltungsstrukturen: Unzulänglichkeiten bekämpfen wir oft mit neuen Gesetzen, neuen Verordnungen und neuen Organisationseinheiten, die das Gesamtgebilde immer komplexer und undurchsichtlicher machen.</p><p>Das einfachste scheint immer zu sein, alles bestehende unangetastet zu lassen und nur neues hinzuzufügen. Immerhin gibt es uns das Gefühl, keinen Schaden an der bereits realisierten Funktionalität anzurichten. Aber das kann nur zu höherer Komplexität führen. In der Tat ist das ein zentrales Phänomen von Legacy-Code: Die längsten, kompliziertesten und unverständlichsten Funktionen und Klassen, die mir begegnet sind, hatten alle eine ähnliche Geschichte: Sie begannen als einfache Gebilde an einer zentralen Stelle des Projekts, in die viele Anforderungen der Folgejahre einflossen. Da sich aber niemand die Mühe machte, das Design selbst infrage zu stellen, wurden weitere Codezeilen eingefügt. Es entstand das bekannte Gewusel aus <code>if</code>-<code>else</code>-Statements und geschachtelten Schleifen, das wir mit Legacy-Code verbinden. Nach einiger Zeit durchblickt auch niemand mehr das Resultat, was jede Refaktorierung noch schwieriger macht. Ähnliches geschieht auch schnell bei der Wartung der Infrastruktur: Eine Serverlandschaft, in der jeder Admin seine eigene Hütte neben die schon bestehenden Gebäude stellt, wird unbeherrschbar.</p><p>Das Vorgehen ist hier einfach, aber das Ergebnis ist es nicht. Daher ist Einfachheit nichts, was von Anfang an gegeben ist, sondern etwas, was mühsam erreicht werden muss. Sie ist das Ergebnis langen Nachdenkens und vieler Refaktorierungen, in denen die Einsicht über das zu lösende Problem und die einfachsten Lösungsmöglichkeiten erst entsteht. Bekannte Entwurfsmuster sind oft elaborierte Strategien, komplexe Probleme möglichst einfach zu lösen.</p><h2 id=\"automatisiertes-testen\">Automatisiertes Testen</h2><p>Der CRAP-Index steht für <em>Change Risk Anti-Pattern</em> und soll ein Maß dafür sein, wie schwierig Wartung und Weiterentwicklung eines Softwareprojekts ist. In die Berechnung gehen dabei zwei Faktoren ein: die Komplexität als positiver Faktor (je höher die Komplexität, desto größer der CRAP-Index) und die Testabdeckung als negativer Faktor (eine höhere Testabdeckung verringert den CRAP-Index). Grund dafür ist, dass eine gute Testabdeckung die negativen Folgen steigender Komplexität abfedern kann: Wenn ein Projekt über gute Tests verfügt, kann die nächste Entwicklerin auch dann Änderungen vornehmen, wenn sie nicht alle bisherigen Anforderungen präsent hat und nicht jeden möglichen Programmablauf überblickt.</p><p>Testen hat – darauf weisen Anhänger des Test Driven Developments zurecht immer wieder hin – aber auch einen erheblichen Einfluss auf das Design innerhalb unserer Anwendungen. Es ermöglicht es, Teile unserer Software primär aus der Sicht des Anwenders zu betrachten. So entstehen einfache und intuitiv nutzbare Schnittstellen sowie leicht beschreibbare und besser dokumentierte Klassen und Funktionen. Gute Tests testen nicht nur, sie gestalten die Struktur unserer Software in einer Weise, die Komplexität beherrschbarer macht.</p><h2 id=\"standards-und-entwurfsmuster\">Standards und Entwurfsmuster</h2><p>Komplexe Strukturen zu durchschauen und zu beherrschen fällt uns leichter, wenn sie uns bekannt sind und sich oft wiederholen. Das ist auch ein Wert verbreiteter Design Patterns: Wir erkennen beispielsweise das Observer-Pattern und wissen, was wir zu erwarten haben. Daher ist eine Software, die sich an verbreiteten Mustern des Designs orientiert, für uns als Entwickler leichter zu verstehen als eine Software, die stets nach eigenen Lösungen sucht oder gänzlich vermeidet, erkennbare Muster zu nutzen (oft geschieht dies aus Angst, solche Muster machten die Software komplizierter).</p><p>Vorhandene weit verbreitete Bibliotheken sind oft besser strukturiert als die eigenen Entwicklungen; sie sind erprobte Mittel bei der Beherrschung von Komplexität, in deren Design oft viel Arbeit geflossen ist. Ein weiterer Vorteil ist: Neue Kolleginnen und Kollegen kennen sie oft schon. Sie haben aus anderen Projekten Erfahrungen mit ihnen mit und erkennen die Verwendungsweisen im aktuellen Projekt wieder. Ähnliches gilt für verbreitete Standards. Sich an diese zu halten, statt eigene Standards einzufügen, erleichtert die Orientierung durch Bekanntheit der Elemente.</p>","comment_id":"63b2758b5a5098039e541c19","feature_image":"https://blog.alexandergunkel.eu/content/images/2023/01/telephone-gc6c014a86_1920.jpg","featured":false,"visibility":"public","created_at":"2023-01-02T07:11:23.000+01:00","updated_at":"2023-01-02T07:24:02.000+01:00","published_at":"2023-01-02T07:24:02.000+01:00","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"url":"https://blog.alexandergunkel.eu/komplexitat-die-tagliche-herausforderung/","excerpt":"Der Umgang mit Komplexität ist die zentrale Herausforderung der meisten Softwareprojekte. Viele Projekte wachsen über die Jahre zu wahren Ungetümen an, deren Wartung immer schwieriger wird. Die Folgen sind oft beschrieben worden: Weitere Veränderungen werden fehleranfällig und dauern immer länger. Neue Kollegen brauchen zunehmend mehr Zeit, sich in den bestehenden Code einzuarbeiten.\n\n\nWas ist eigentlich Komplexität?\n\nKomplexität in dem hier beschriebenen Sinne entspricht nicht dem, was die Info","reading_time":7,"access":true,"comments":false,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"email_subject":null,"frontmatter":null,"feature_image_alt":"Mast mit Telefonverbindungen","feature_image_caption":"Komplexität entsteht durch unübersichtliche Verbindungen"}],"meta":{"pagination":{"page":1,"limit":15,"pages":1,"total":5,"next":null,"prev":null}}}